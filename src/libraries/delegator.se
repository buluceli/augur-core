# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern controllerExtern: [lookup:[int256]:address]

data controller
data key

def any():
    if (self.controller and self.key):
        # we need to call this method and specify a location in memory (offset 0) to store the results so we can use it later. if we let the compiler do it, it sometimes re-orders the call to _after_ our calldatacopy call which results in the compiler generated bytecode blowing away a chunk of our memory
        ~mstore(0, self.controller.lookup(self.key))
        # this copies the method signature and parameters into memory starting at offset 32 (offset [0-32) is used above)
        ~calldatacopy(32, 0, ~calldatasize())
        # call the library contract at the method signature provided and with the parameters provided, then write the results into memory at offset 0.
        # TODO: figure out how much gas is used up to this point and replace the -10000
        if not ~delegatecall(msg.gas - 10000, ~mload(0), 32, ~calldatasize(), 0, 32):
            ~invalid()
        # return the result of the library call to the caller, limited to 32-bytes returned
        ~return(0, 32)

def setup(controller, key):
    self.controller = controller
    self.key = key
